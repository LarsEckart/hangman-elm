#!/usr/bin/env node

/**
 * Build script to generate embedded word lists from CSV files
 * Transforms src/wordlists/*.csv into src/Generated/WordLists.elm
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CSV_DIR = path.join(__dirname, '..', 'src', 'wordlists');
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'Generated');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'WordLists.elm');

// Supported languages, categories, and difficulties
const LANGUAGES = ['english', 'german', 'estonian'];
const CATEGORIES = ['animals', 'food', 'sport'];
const DIFFICULTIES = ['easy', 'medium', 'hard'];

// Word length requirements for difficulties
const DIFFICULTY_REQUIREMENTS = {
    easy: { min: 3, max: 5 },
    medium: { min: 6, max: 8 },
    hard: { min: 9, max: 15 }
};

/**
 * Parse a CSV file and return array of words
 */
function parseCSV(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        return content
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);
    } catch (error) {
        console.warn(`Warning: Could not read ${filePath}: ${error.message}`);
        return [];
    }
}

/**
 * Validate word list against difficulty requirements
 */
function validateWordList(words, difficulty) {
    const requirements = DIFFICULTY_REQUIREMENTS[difficulty];
    const validWords = words.filter(word => {
        const length = word.length;
        return length >= requirements.min && length <= requirements.max;
    });

    if (validWords.length !== words.length) {
        const invalidWords = words.filter(word => {
            const length = word.length;
            return length < requirements.min || length > requirements.max;
        });
        console.warn(`Warning: ${difficulty} difficulty has ${invalidWords.length} words with invalid length:`, invalidWords);
    }

    return validWords;
}

/**
 * Discover and parse all CSV files
 */
function loadWordLists() {
    const wordLists = {};
    let totalFiles = 0;
    let loadedFiles = 0;

    // Initialize nested structure
    LANGUAGES.forEach(lang => {
        wordLists[lang] = {};
        CATEGORIES.forEach(cat => {
            wordLists[lang][cat] = [];
        });
    });

    // Load CSV files
    LANGUAGES.forEach(language => {
        CATEGORIES.forEach(category => {
            const filename = `${language}-${category}.csv`;
            const filePath = path.join(CSV_DIR, filename);
            totalFiles++;

            if (fs.existsSync(filePath)) {
                const words = parseCSV(filePath);
                wordLists[language][category] = words;
                loadedFiles++;
                console.log(`‚úì Loaded ${words.length} words from ${filename}`);
            } else {
                console.warn(`‚ö† Missing file: ${filename}`);
            }
        });
    });

    console.log(`\nLoaded ${loadedFiles}/${totalFiles} CSV files`);
    return wordLists;
}

/**
 * Generate Elm code from word lists
 */
function generateElmCode(wordLists) {
    const timestamp = new Date().toISOString().split('T')[0];
    
    let elmCode = `-- Generated by build-wordlists.js on ${timestamp}
-- Do not edit manually - regenerate with: npm run build-wordlists

module Generated.WordLists exposing (..)

import Dict exposing (Dict)
import Types exposing (Language(..), Category(..))


-- 2-dimensional nested Dict structure for efficient lookup
type alias WordListDB = Dict String (Dict String (List String))


-- Generated word database: language -> category -> word list
wordListDB : WordListDB
wordListDB = 
    Dict.fromList
        [`;

    // Generate language entries
    const languageEntries = LANGUAGES.map(language => {
        const categoryEntries = CATEGORIES.map(category => {
            const words = wordLists[language][category];
            const wordList = words.map(word => `"${word.toUpperCase()}"`).join(', ');
            return `            ("${category}", [${wordList}])`;
        }).join('\n            , ');

        return `        ("${language}", Dict.fromList
            [ ${categoryEntries}
            ])`;
    }).join('\n        , ');

    elmCode += `
${languageEntries}
        ]


-- Primary lookup function
getWordList : Language -> Category -> List String
getWordList language category =
    wordListDB
        |> Dict.get (languageToString language)
        |> Maybe.andThen (Dict.get (categoryToString category))
        |> Maybe.withDefault []


-- Helper functions for key generation
languageToString : Language -> String
languageToString language =
    case language of
        English -> "english"
        German -> "german"
        Estonian -> "estonian"


categoryToString : Category -> String
categoryToString category =
    case category of
        Animals -> "animals"
        Food -> "food"
        Sport -> "sport"


-- Validation and utility functions
getAvailableCombinations : List (Language, Category)
getAvailableCombinations =
    let
        combinations = []
            ++ List.concatMap (\\lang -> 
                List.filterMap (\\cat -> 
                    if List.isEmpty (getWordList lang cat) then
                        Nothing
                    else
                        Just (lang, cat)
                ) [Animals, Food, Sport]
            ) [English, German, Estonian]
    in
    combinations
`;

    return elmCode;
}

/**
 * Write generated Elm code to file
 */
function writeElmFile(elmCode) {
    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
        console.log(`Created directory: ${OUTPUT_DIR}`);
    }

    // Write the file
    fs.writeFileSync(OUTPUT_FILE, elmCode, 'utf8');
    console.log(`\n‚úì Generated: ${OUTPUT_FILE}`);
}

/**
 * Main execution
 */
function main() {
    console.log('Building embedded word lists...\n');

    try {
        // Load and validate CSV files
        const wordLists = loadWordLists();

        // Generate Elm code
        const elmCode = generateElmCode(wordLists);

        // Write output file
        writeElmFile(elmCode);

        console.log('\nüéâ Build completed successfully!');
        
        // Print summary
        let totalWords = 0;
        LANGUAGES.forEach(lang => {
            CATEGORIES.forEach(cat => {
                totalWords += wordLists[lang][cat].length;
            });
        });
        console.log(`üìä Total words embedded: ${totalWords}`);

    } catch (error) {
        console.error('‚ùå Build failed:', error.message);
        process.exit(1);
    }
}

// Run the script
if (require.main === module) {
    main();
}

module.exports = { loadWordLists, generateElmCode };