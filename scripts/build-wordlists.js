#!/usr/bin/env node

/**
 * Build script to generate embedded word lists from CSV files
 * Transforms src/wordlists/*.csv into src/Generated/WordLists.elm
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CSV_DIR = path.join(__dirname, '..', 'src', 'wordlists');
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'Generated');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'WordLists.elm');

// Supported languages, categories, and difficulties
const LANGUAGES = ['english', 'german', 'estonian'];
const CATEGORIES = ['animals', 'food', 'sport'];
const DIFFICULTIES = ['easy', 'medium', 'hard'];

// Word length requirements for difficulties
const DIFFICULTY_REQUIREMENTS = {
    easy: { min: 3, max: 5 },
    medium: { min: 6, max: 8 },
    hard: { min: 9, max: 15 }
};

/**
 * Parse a CSV file and return array of words
 */
function parseCSV(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        return content
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);
    } catch (error) {
        console.warn(`Warning: Could not read ${filePath}: ${error.message}`);
        return [];
    }
}

/**
 * Validate word list against difficulty requirements
 */
function validateWordList(words, difficulty) {
    const requirements = DIFFICULTY_REQUIREMENTS[difficulty];
    const validWords = words.filter(word => {
        const length = word.length;
        return length >= requirements.min && length <= requirements.max;
    });

    if (validWords.length !== words.length) {
        const invalidWords = words.filter(word => {
            const length = word.length;
            return length < requirements.min || length > requirements.max;
        });
        console.warn(`Warning: ${difficulty} difficulty has ${invalidWords.length} words with invalid length:`, invalidWords);
    }

    return validWords;
}

/**
 * Discover and parse all CSV files
 */
function loadWordLists() {
    const wordLists = {};
    let totalFiles = 0;
    let loadedFiles = 0;

    // Initialize nested structure
    LANGUAGES.forEach(lang => {
        wordLists[lang] = {};
        CATEGORIES.forEach(cat => {
            wordLists[lang][cat] = {};
            DIFFICULTIES.forEach(diff => {
                wordLists[lang][cat][diff] = [];
            });
        });
    });

    // Load CSV files
    LANGUAGES.forEach(language => {
        CATEGORIES.forEach(category => {
            DIFFICULTIES.forEach(difficulty => {
                const filename = `${language}-${category}-${difficulty}.csv`;
                const filePath = path.join(CSV_DIR, filename);
                totalFiles++;

                if (fs.existsSync(filePath)) {
                    const words = parseCSV(filePath);
                    const validWords = validateWordList(words, difficulty);
                    wordLists[language][category][difficulty] = validWords;
                    loadedFiles++;
                    console.log(`‚úì Loaded ${validWords.length} words from ${filename}`);
                } else {
                    console.warn(`‚ö† Missing file: ${filename}`);
                }
            });
        });
    });

    console.log(`\nLoaded ${loadedFiles}/${totalFiles} CSV files`);
    return wordLists;
}

/**
 * Generate Elm code from word lists
 */
function generateElmCode(wordLists) {
    const timestamp = new Date().toISOString().split('T')[0];
    
    let elmCode = `-- Generated by build-wordlists.js on ${timestamp}
-- Do not edit manually - regenerate with: npm run build-wordlists

module Generated.WordLists exposing (..)

import Dict exposing (Dict)
import Types exposing (Language(..), Category(..), Difficulty(..))


-- 3-dimensional nested Dict structure for efficient lookup
type alias WordListDB = Dict String (Dict String (Dict String (List String)))


-- Generated word database: language -> category -> difficulty -> word list
wordListDB : WordListDB
wordListDB = 
    Dict.fromList
        [`;

    // Generate language entries
    const languageEntries = LANGUAGES.map(language => {
        const categoryEntries = CATEGORIES.map(category => {
            const difficultyEntries = DIFFICULTIES.map(difficulty => {
                const words = wordLists[language][category][difficulty];
                const wordList = words.map(word => `"${word.toUpperCase()}"`).join(', ');
                return `                    ("${difficulty}", [${wordList}])`;
            }).join('\n                , ');

            return `            ("${category}", Dict.fromList
                [ ${difficultyEntries}
                ])`;
        }).join('\n            , ');

        return `        ("${language}", Dict.fromList
            [ ${categoryEntries}
            ])`;
    }).join('\n        , ');

    elmCode += `
${languageEntries}
        ]


-- Primary lookup function
getWordList : Language -> Category -> Difficulty -> List String
getWordList language category difficulty =
    wordListDB
        |> Dict.get (languageToString language)
        |> Maybe.andThen (Dict.get (categoryToString category))
        |> Maybe.andThen (Dict.get (difficultyToString difficulty))
        |> Maybe.withDefault []


-- Helper functions for key generation
languageToString : Language -> String
languageToString language =
    case language of
        English -> "english"
        German -> "german"
        Estonian -> "estonian"


categoryToString : Category -> String
categoryToString category =
    case category of
        Animals -> "animals"
        Food -> "food"
        Sport -> "sport"


difficultyToString : Difficulty -> String
difficultyToString difficulty =
    case difficulty of
        Easy -> "easy"
        Medium -> "medium"
        Hard -> "hard"


-- Validation and utility functions
getAvailableCombinations : List (Language, Category, Difficulty)
getAvailableCombinations =
    let
        combinations = []
            ++ List.concatMap (\\lang -> 
                List.concatMap (\\cat -> 
                    List.filterMap (\\diff -> 
                        if List.isEmpty (getWordList lang cat diff) then
                            Nothing
                        else
                            Just (lang, cat, diff)
                    ) [Easy, Medium, Hard]
                ) [Animals, Food, Sport]
            ) [English, German, Estonian]
    in
    combinations


validateWordList : List String -> Difficulty -> Bool
validateWordList words difficulty =
    let
        requirements = case difficulty of
            Easy -> { min = 3, max = 5 }
            Medium -> { min = 6, max = 8 }
            Hard -> { min = 9, max = 15 }
        
        isValidWord word =
            let
                length = String.length word
            in
            length >= requirements.min && length <= requirements.max
    in
    List.all isValidWord words
`;

    return elmCode;
}

/**
 * Write generated Elm code to file
 */
function writeElmFile(elmCode) {
    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
        console.log(`Created directory: ${OUTPUT_DIR}`);
    }

    // Write the file
    fs.writeFileSync(OUTPUT_FILE, elmCode, 'utf8');
    console.log(`\n‚úì Generated: ${OUTPUT_FILE}`);
}

/**
 * Main execution
 */
function main() {
    console.log('Building embedded word lists...\n');

    try {
        // Load and validate CSV files
        const wordLists = loadWordLists();

        // Generate Elm code
        const elmCode = generateElmCode(wordLists);

        // Write output file
        writeElmFile(elmCode);

        console.log('\nüéâ Build completed successfully!');
        
        // Print summary
        let totalWords = 0;
        LANGUAGES.forEach(lang => {
            CATEGORIES.forEach(cat => {
                DIFFICULTIES.forEach(diff => {
                    totalWords += wordLists[lang][cat][diff].length;
                });
            });
        });
        console.log(`üìä Total words embedded: ${totalWords}`);

    } catch (error) {
        console.error('‚ùå Build failed:', error.message);
        process.exit(1);
    }
}

// Run the script
if (require.main === module) {
    main();
}

module.exports = { loadWordLists, generateElmCode, validateWordList };